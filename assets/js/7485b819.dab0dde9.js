"use strict";(self.webpackChunkdeveloper_newcoin_org_2=self.webpackChunkdeveloper_newcoin_org_2||[]).push([[5348],{3905:(t,e,n)=>{n.d(e,{Zo:()=>s,kt:()=>f});var i=n(7294);function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function r(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,i)}return n}function a(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?r(Object(n),!0).forEach((function(e){o(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function c(t,e){if(null==t)return{};var n,i,o=function(t,e){if(null==t)return{};var n,i,o={},r=Object.keys(t);for(i=0;i<r.length;i++)n=r[i],e.indexOf(n)>=0||(o[n]=t[n]);return o}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(i=0;i<r.length;i++)n=r[i],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(o[n]=t[n])}return o}var l=i.createContext({}),u=function(t){var e=i.useContext(l),n=e;return t&&(n="function"==typeof t?t(e):a(a({},e),t)),n},s=function(t){var e=u(t.components);return i.createElement(l.Provider,{value:e},t.children)},d="mdxType",h={inlineCode:"code",wrapper:function(t){var e=t.children;return i.createElement(i.Fragment,{},e)}},p=i.forwardRef((function(t,e){var n=t.components,o=t.mdxType,r=t.originalType,l=t.parentName,s=c(t,["components","mdxType","originalType","parentName"]),d=u(n),p=o,f=d["".concat(l,".").concat(p)]||d[p]||h[p]||r;return n?i.createElement(f,a(a({ref:e},s),{},{components:n})):i.createElement(f,a({ref:e},s))}));function f(t,e){var n=arguments,o=e&&e.mdxType;if("string"==typeof t||o){var r=n.length,a=new Array(r);a[0]=p;var c={};for(var l in e)hasOwnProperty.call(e,l)&&(c[l]=e[l]);c.originalType=t,c[d]="string"==typeof t?t:o,a[1]=c;for(var u=2;u<r;u++)a[u]=n[u];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}p.displayName="MDXCreateElement"},1805:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>c,toc:()=>u});var i=n(7462),o=(n(7294),n(3905));const r={},a="Step 4: Interacting with the Encoder and Activating the Function",c={unversionedId:"guides/gitcoin-chainlink-guild/registering-the-function",id:"guides/gitcoin-chainlink-guild/registering-the-function",title:"Step 4: Interacting with the Encoder and Activating the Function",description:"Once the activation function has been implemented and deployed, the next step is to interact with the Newcoin Encoder to register and activate the function, thereby minting WATTs upon successful condition checks.",source:"@site/docs/guides/gitcoin-chainlink-guild/registering-the-function.md",sourceDirName:"guides/gitcoin-chainlink-guild",slug:"/guides/gitcoin-chainlink-guild/registering-the-function",permalink:"/docs/guides/gitcoin-chainlink-guild/registering-the-function",draft:!1,editUrl:"https://github.com/newfound8ion/developer/edit/master/docs/guides/gitcoin-chainlink-guild/registering-the-function.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Step 3: Ensuring Secure and Efficient Contract Operation",permalink:"/docs/guides/gitcoin-chainlink-guild/securing-the-contract"},next:{title:"Introduction",permalink:"/docs/guides/joke-vote-race/introduction"}},l={},u=[{value:"A. Registering the Activation Function with the Encoder",id:"a-registering-the-activation-function-with-the-encoder",level:2},{value:"B. Activation of the Function",id:"b-activation-of-the-function",level:2},{value:"Activation Call:",id:"activation-call",level:3},{value:"Conclusion of Step 4:",id:"conclusion-of-step-4",level:2}],s={toc:u},d="wrapper";function h(t){let{components:e,...n}=t;return(0,o.kt)(d,(0,i.Z)({},s,n,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"step-4-interacting-with-the-encoder-and-activating-the-function"},"Step 4: Interacting with the Encoder and Activating the Function"),(0,o.kt)("p",null,"Once the activation function has been implemented and deployed, the next step is to interact with the Newcoin Encoder to register and activate the function, thereby minting WATTs upon successful condition checks."),(0,o.kt)("h2",{id:"a-registering-the-activation-function-with-the-encoder"},"A. Registering the Activation Function with the Encoder"),(0,o.kt)("p",null,"Before an activation function can mint WATTs, it must be registered and approved by the Newcoin Encoder. This process involves providing details about the function and awaiting approval from the Newcoin Foundation."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function registerActivationFunction(\n    WattType _wattType,\n    uint256 _multiplier,\n    string memory _context,\n    address _addrss,\n    uint256 _weightInWatt,\n    bool _isAsync\n) external returns (uint256);\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"_","wattType: Type of WATT to be minted."),(0,o.kt)("li",{parentName:"ul"},"_","multiplier: Multiplier value to calculate the minted amount."),(0,o.kt)("li",{parentName:"ul"},"_","context: A descriptive string explaining the activation function."),(0,o.kt)("li",{parentName:"ul"},"_","addrss: Address of the activation function contract."),(0,o.kt)("li",{parentName:"ul"},"_","weightInWatt: The amount of WATTs to be minted upon successful activation."),(0,o.kt)("li",{parentName:"ul"},"_","isAsync: A boolean indicating if the activation function is asynchronous.")),(0,o.kt)("p",null,"After registration, the function will return an ID that will be used to interact with the activation function in the future. Store this ID securely."),(0,o.kt)("h2",{id:"b-activation-of-the-function"},"B. Activation of the Function"),(0,o.kt)("p",null,"Upon approval from the Newcoin Foundation, users can run the activation function to mint tokens. This involves calling the activate function on the Encoder, supplying the ID of the approved activation function."),(0,o.kt)("h3",{id:"activation-call"},"Activation Call:"),(0,o.kt)("p",null,"We would then run the activate() function on the Encoder, passing it our activationFunctionId."),(0,o.kt)("p",null,"When a user calls the activate function with the appropriate activationFunctionId, the Encoder will interact with the specified activation function to check if conditions are met. Upon successful validation, WATTs are minted according to our predefined logic in the activation function - membership of the Guild and holders of the Gitcoin Passport."),(0,o.kt)("h2",{id:"conclusion-of-step-4"},"Conclusion of Step 4:"),(0,o.kt)("p",null,"In this step, we've covered:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"How to register the activation function with the Encoder, providing relevant details and obtaining a unique ID."),(0,o.kt)("li",{parentName:"ul"},"How to activate the function, interacting with the Encoder and triggering the logic to mint WATTs.")),(0,o.kt)("p",null,"By effectively interacting with the Encoder, developers ensure that the activation functions can mint WATTs upon successfully validating predefined conditions, thereby contributing to the user\u2019s algorithmic reputation within the Newcoin ecosystem. This seamless integration enables the efficient minting of WATTs, providing a tangible representation of real-world activities and verifications on the blockchain."))}h.isMDXComponent=!0}}]);